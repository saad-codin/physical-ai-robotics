"""Translation service for multi-language content support."""
import logging
from typing import Dict, List, Optional
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

from src.models.lesson import Lesson
from src.models.content_translation import ContentTranslation
from src.models.user import User
from src.crud.lesson import get_lesson
from src.crud.content_translation import (
    get_content_translation_by_lesson_and_language,
    get_content_translations_by_lesson,
    create_content_translation
)
from src.utils.llm_integrations import generate_llm_response
from src.config import settings

logger = logging.getLogger(__name__)

class TranslationService:
    """Service class for handling content translation and localization."""

    async def get_translated_content(
        self,
        db: AsyncSession,
        lesson_id: UUID,
        target_language: str,
        user: Optional[User] = None
    ) -> Dict[str, str]:
        """
        Get translated content for a lesson in the target language.

        If no translation exists, it will be created using LLM translation.

        Args:
            db: Database session
            lesson_id: ID of the lesson to translate
            target_language: Target language code (e.g., 'es', 'fr', 'zh')
            user: Optional user for personalization

        Returns:
            Dictionary with translated title and content
        """
        # First, check if translation already exists
        existing_translation = await get_content_translation_by_lesson_and_language(
            db, lesson_id, target_language
        )

        if existing_translation:
            logger.info(f"Found existing translation for lesson {lesson_id} in {target_language}")
            return {
                "title": existing_translation.translated_title,
                "content": existing_translation.translated_content_markdown
            }

        # If no translation exists, create one
        lesson = await get_lesson(db, lesson_id)
        if not lesson:
            raise ValueError(f"Lesson with ID {lesson_id} not found")

        logger.info(f"Creating new translation for lesson {lesson_id} in {target_language}")

        # Use LLM to translate the content
        translated_content = await self._translate_with_llm(
            lesson.title,
            lesson.content_markdown,
            target_language
        )

        # Create translation record in database
        translation_data = {
            "lesson_id": lesson_id,
            "language_code": target_language,
            "translated_title": translated_content["title"],
            "translated_content_markdown": translated_content["content"]
        }

        await create_content_translation(db, translation_data)

        return translated_content

    async def _translate_with_llm(
        self,
        title: str,
        content: str,
        target_language: str
    ) -> Dict[str, str]:
        """
        Translate content using LLM.

        Args:
            title: Original title to translate
            content: Original content to translate
            target_language: Target language code

        Returns:
            Dictionary with translated title and content
        """
        # Construct translation prompt
        prompt = f"""
        You are a professional translator. Translate the following content to {target_language}.

        Original Title:
        {title}

        Original Content:
        {content}

        Translation Guidelines:
        - Preserve technical terminology accurately
        - Maintain the original meaning and context
        - Keep markdown formatting intact
        - Do not add any explanations or notes

        Translated Title:
        """

        # Use the LLM to generate translation
        # Note: This is a simplified implementation - in production, you might want to
        # split large content into chunks to respect token limits
        try:
            # For now, we'll use a mock response to avoid actually calling the LLM during setup
            # In a real implementation, you would call the LLM service
            logger.info(f"Translating to {target_language} using LLM")

            # Create a mock translation response
            # In a real implementation, this would be generated by the LLM
            import re

            # For demonstration purposes, we'll just return the original content
            # with a note that it's translated (in a real system, actual translation would happen)
            translated_title = f"[{target_language.upper()}] {title}"
            translated_content = f"Translated content in {target_language}:\n\n{content}"

            return {
                "title": translated_title,
                "content": translated_content
            }
        except Exception as e:
            logger.error(f"Error translating content: {e}")
            # Return original content if translation fails
            return {
                "title": title,
                "content": content
            }

    async def get_available_translations(
        self,
        db: AsyncSession,
        lesson_id: UUID
    ) -> List[Dict[str, str]]:
        """
        Get all available translations for a lesson.

        Args:
            db: Database session
            lesson_id: ID of the lesson

        Returns:
            List of available translations with language codes
        """
        translations = await get_content_translations_by_lesson(db, lesson_id)

        result = []
        for translation in translations:
            result.append({
                "language_code": translation.language_code,
                "title": translation.translated_title,
                "translated_at": translation.created_at.isoformat() if translation.created_at else None,
                "reviewed": translation.reviewed_at is not None
            })

        return result

    def get_supported_languages(self) -> List[Dict[str, str]]:
        """
        Get list of supported languages.

        Returns:
            List of supported languages with codes and names
        """
        # Get supported languages from settings
        supported_codes = settings.supported_languages
        language_names = {
            "en": "English",
            "zh": "Chinese",
            "es": "Spanish",
            "fr": "French",
            "de": "German",
            "ja": "Japanese",
            "ko": "Korean",
            "ur": "Urdu"
        }

        result = []
        for code in supported_codes:
            name = language_names.get(code, code)
            result.append({
                "code": code,
                "name": name
            })

        return result

# Global instance
translation_service = TranslationService()